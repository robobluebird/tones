<html>
  <head>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: sans-serif;
      }

      .cont {
        display: inline-block;
      }

      .proto {
        display: none;
      }

      table.pattern {
        cursor: pointer;
      }

      table.pattern td {
        width: 20px;
        height: 20px;
      }

      table.pattern tr:nth-child(odd) td:nth-child(2n) {
        background-color: #CCCCCC;
      }

      table.pattern tr:nth-child(odd) td:nth-child(2n+1) {
        background-color: #EEEEEE;
      }

      table.pattern tr:nth-child(even) td:nth-child(even) {
        background-color: #EEEEEE;
      }

      table.pattern tr:nth-child(even) td:nth-child(odd) {
        background-color: #CCCCCC;
      }

      table.pattern tr:nth-child(odd) td.on {
        background-color: red;
      }

      table.pattern tr:nth-child(even) td.on {
        background-color: red;
      }

      table.pattern tr:nth-child(odd) td.red {
        background-color: red;
      }

      table.pattern tr:nth-child(odd) td.blue {
        background-color: blue;
      }

      table.pattern tr:nth-child(odd) td.green {
        background-color: green;
      }

      table.pattern tr:nth-child(odd) td.orange {
        background-color: orange;
      }

      table.pattern tr:nth-child(even) td.red {
        background-color: red;
      }

      table.pattern tr:nth-child(even) td.blue {
        background-color: blue;
      }

      table.pattern tr:nth-child(even) td.green {
        background-color: green;
      }

      table.pattern tr:nth-child(even) td.orange {
        background-color: orange;
      }

      table.pattern tr:nth-child(odd) td:hover {
        background-color: #AAAAAA;
      }

      table.pattern tr:nth-child(even) td:hover {
        background-color: #AAAAAA;
      }

      table.pattern tr:nth-child(odd) td:hover.red {
        background-color: red;
      }

      table.pattern tr:nth-child(odd) td:hover.blue {
        background-color: blue;
      }

      table.pattern tr:nth-child(odd) td:hover.green {
        background-color: green;
      }

      table.pattern tr:nth-child(odd) td:hover.orange {
        background-color: orange;
      }

      table.pattern tr:nth-child(even) td:hover.red {
        background-color: red;
      }

      table.pattern tr:nth-child(even) td:hover.blue {
        background-color: blue;
      }

      table.pattern tr:nth-child(even) td:hover.green {
        background-color: green;
      }

      table.pattern tr:nth-child(even) td:hover.orange {
        background-color: orange;
      }
    </style>
  </head>
  <body>
    <div style="text-align: center">
      <p class="line" style="display: none;"></p>
      <button onclick="loop()">loop</button>
      <button onclick="stop()">stop</button>
      <button onclick="createChart()">add</button>
      <input id="bpm" type="number" min="40" max="200" value="120" />
    </div>
    <div class="cont chartContainer proto">
      <table>
        <tr><td>C</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td>B</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td>A#</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td>A</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td>G#</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td>G</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td>F#</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td>F</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td>E</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td>D#</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td>D</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td>C#</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td>C</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
      </table>
      <button style="float: right;" class="delete">delete</button>
      <select class="tone">
        <option value=0>square</option>
        <option selected value=1>sine</option>
        <option value=2>triangle</option>
        <option value=3>fuzz</option>
      <select>
      <select class="root">
        <option selected value="C">C</option>
        <option value="C#">C#</option>
        <option value="D">D</option>
        <option value="D#">D#</option>
        <option value="E">E</option>
        <option value="E#">E#</option>
        <option value="F">F</option>
        <option value="G">G</option>
        <option value="G#">G#</option>
        <option value="A">A</option>
        <option value="A#">A#</option>
        <option value="B">B</option>
      </select>
      <select class="octave">
        <option value=1>1</option>
        <option value=2>2</option>
        <option value=3>3</option>
        <option selected value=4>4</option>
        <option value=5>5</option>
        <option value=6>6</option>
        <option value=7>7</option>
        <option value=8>8</option>
      </select>
    </div>
  </body>
  <script type="text/javascript">
    const toneConstant = 1.059463
    const notes = []
    const sampleRate = 44100
    const data = []
    const tones = []
    const rootNotes = []
    const octaves = []
    const noteNamesAndFreqs = {
      C: 262,
      'C#': 277,
      D: 294,
      'D#': 311,
      E: 330,
      F: 349,
      'F#': 370,
      G: 392,
      'G#': 415,
      A: 440,
      'A#': 466,
      B: 494
    }

    let playing = false
    let bpm = 110
    let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let beatsPerSecond = bpm / 60.0
    let secondsPerBeat = 1.0 / beatsPerSecond
    let seconds = secondsPerBeat * 4
    let bufferSize = parseInt(seconds * sampleRate)
    let subBufferSize = parseInt(bufferSize / 16)
    let buffer = audioCtx.createBuffer(1, bufferSize, sampleRate);
    let bufferSource

    const generateNoteNames = (startNote) => {
      const noteNames = Object.keys(noteNamesAndFreqs)
      let index = noteNames.indexOf(startNote)

      if (index === -1) {
        return []
      }

      let names = []
      let namesIndex = 0

      while (namesIndex <= 12) {
        if (index > 11) {
          index = 0
        }

        names[namesIndex] = noteNames[index]

        index++
        namesIndex++
      }

      names[namesIndex] = startNote

      return names
    }

    const forEach = (array, callback, scope) => {
      for (let i = 0; i < array.length; i++) {
        callback.call(scope, i, array[i]);
      }
    }

    const paintAll = () => {
      data.forEach((chart, index) => {
        const table = document.querySelector(`#chart${index}`)
        const trs = table.querySelectorAll(':scope tbody tr')

        forEach(trs, (i, tr) => {
          const tds = tr.querySelectorAll(':scope td');

          forEach(tds, (j, td) => {
            if (data[index][j] === i) {
              td.className = toneClass(tones[index] || 0)
            } else {
              td.className = ''
            }
          })
        })
      })
    }

    const toneClass = (index) => {
      switch (index) {
        case 0:
          return 'red'
        case 1:
          return 'blue'
        case 2:
          return 'green'
        case 3:
          return 'orange'
      }
    }

    const changeTempo = (e) => {
      let restart = false

      if (playing) {
        restart = true
      }

      stop()
      
      bpm = parseInt(e.target.value)

      beatsPerSecond = bpm / 60.0
      secondsPerBeat = 1.0 / beatsPerSecond
      seconds = secondsPerBeat * 4
      bufferSize = parseInt(seconds * sampleRate)
      subBufferSize = parseInt(bufferSize / 16)
      buffer = audioCtx.createBuffer(1, bufferSize, sampleRate);

      generateTones()

      if (restart) {
        loop()
      }

      history.replaceState(null, '', '?p=' + encodeAll())
    }

    const changeTone = (index, e) => {
      tones[index] = parseInt(e.target.value)
      history.replaceState(null, '', '?p=' + encodeAll())
      paintAll()
      generateTones()
    }

    const changeOctave = (index, e) => {
      octaves[index] = parseInt(e.target.value)
      history.replaceState(null, '', '?p=' + encodeAll())
      generateNotes(index)
      paintAll()
      generateTones()
    }

    const setNoteText = (index, note) => {
      const newNotes = generateNoteNames(note)
      const table = document.querySelector(`#chart${index}`)
      const trs = table.querySelectorAll(':scope tr')

      forEach(trs, (rowIndex, tr) => {
        const firstTd = tr.querySelector('td')

        if (rowIndex < newNotes.length) {
          firstTd.innerText = newNotes[rowIndex]
        } else {
          firstTd.innerText = newNotes[0]
        }
      })
    }

    const changeRoot = (index, e) => {
      const note = e.target.value

      setNoteText(index, note)
      rootNotes[index] = note
      history.replaceState(null, '', '?p=' + encodeAll())
      generateNotes(index)
      paintAll()
      generateTones()
    }

    const generateNotes = (index) => {
      let octaveShift = Math.pow(toneConstant, 12)
      let octaveShiftCount = 0

      if (octaves[index] < 4) {
        octaveShift = 1 / Math.pow(toneConstant, 12)
        octaveShiftCount = 4 - octaves[index]
      } else if (octaves[index] > 4) {
        octaveShiftCount = octaves[index] - 4
      }

      let rootValue = noteNamesAndFreqs[rootNotes[index]]
      for (let i = 0; i < octaveShiftCount; i++) {
        rootValue = rootValue * octaveShift 
      }

      notes[index] = []
      notes[index][12] = rootValue

      for (let i = 12; i >= 0; i--) {
        notes[index][12 - i] = generateNoteFrequency(i, rootValue)
      }
    }

    const deleteChart = (index) => {
      if (data.length <= 1) {
        return
      }

      document.querySelector(`#container${index}`).remove()

      data.splice(index, 1)

      while (index < data.length) {
        let cont = document.querySelector(`#container${index + 1}`)
        let tab = cont.querySelector(`#chart${index + 1}`)
        let del = cont.querySelector('button.delete')
        let lis = cont.querySelector('select.tone')
        let roo = cont.querySelector('select.root')
        let oct = cont.querySelector('select.octave')

        cont.id = `container${index}`
        tab.id = `chart${index}`
        del.onclick = () => deleteChart(index)
        lis.id = `inst${index}`
        lis.onchange = (e) => changeTone(index, e)
        roo.id = `root${index}`
        roo.onchange = (e) => changeRoot(index, e)
        oct.id = `octave${index}`
        oct.onchange = (e) => changeOctave(index, e)

        index++
      }
    }

    const createChart = () => {
      const proto = document.querySelector("div.proto")
      const body = document.querySelector('body')
      const chartIndex = data.length

      let chartContainer = proto.cloneNode(true)
      let chart = chartContainer.querySelector('table')
      let deleteButton = chartContainer.querySelector('button.delete')
      let lis = chartContainer.querySelector('select.tone')
      let roo = chartContainer.querySelector('select.root')
      let oct = chartContainer.querySelector('select.octave')

      chartContainer.classList.remove('proto')
      chartContainer.id = `container${chartIndex}`
      chart.className = 'pattern'
      chart.id = `chart${chartIndex}`
      deleteButton.onclick = () => deleteChart(chartIndex)
      lis.id = `inst${index}`
      lis.onchange = (e) => changeTone(chartIndex, e)
      roo.id = `root${chartIndex}`
      roo.onchange = (e) => changeRoot(chartIndex, e)
      oct.id = `octave${chartIndex}`
      oct.onchange = (e) => changeOctave(chartIndex, e)


      body.insertBefore(chartContainer, proto)

      data[chartIndex] = []

      const trs = chart.querySelectorAll(':scope tr')

      forEach(trs, (rowIndex, tr) => {
        const tds = tr.querySelectorAll(':scope td')

        forEach(tds, (dataIndex, td) => {
          td.onclick = (e) => {
            if (data[chartIndex][dataIndex] === rowIndex) {
              data[chartIndex][dataIndex] = null
            } else {
              data[chartIndex][dataIndex] = rowIndex
            }

            history.replaceState(null, '', '?p=' + encodeAll())
            paintAll()
            generateTones()
          }
        })
      })

      paintAll()
      generateTones()
    }

    const createCharts = () => {
      const proto = document.querySelector("div.proto")
      const body = document.querySelector('body')

      if (data.length === 0) {
        data[0] = []
      }

      data.forEach((data, chartIndex) => {
        let chartContainer = proto.cloneNode(true)
        let chart = chartContainer.querySelector('table')
        let deleteButton = chartContainer.querySelector('button.delete')
        let lis = chartContainer.querySelector('select.tone')
        let roo = chartContainer.querySelector('select.root')
        let oct = chartContainer.querySelector('select.octave')

        chartContainer.classList.remove('proto')
        chartContainer.id = `container${chartIndex}`
        chart.className = 'pattern'
        chart.id = `chart${chartIndex}`
        deleteButton.onclick = () => deleteChart(chartIndex)
        lis.id = `inst${chartIndex}`
        lis.onchange = (e) => changeTone(chartIndex, e)
        roo.id = `root${chartIndex}`
        roo.onchange = (e) => changeRoot(chartIndex, e)
        oct.id = `octave${chartIndex}`
        oct.onchange = (e) => changeOctave(chartIndex, e)

        body.insertBefore(chartContainer, proto)
      })
    }

    const setInsts = () => {
      tones.forEach((tone, index) => {
        let inst = document.querySelector(`#inst${index}`)
        inst.value = tone
      })
    }

    const setRoots = () => {
      rootNotes.forEach((root, index) => {
        let r = document.querySelector(`#root${index}`)
        r.value = root
        setNoteText(index, root)
      })
    }

    const setOctaves = () => {
      octaves.forEach((octave, index) => {
        let o = document.querySelector(`#octave${index}`)
        o.value = octave
      })
    }

    const init = () => {
      // fetch initial pattern from params and fill data with it
      const params = (new URL(document.location)).searchParams
      const patternsParam = params.get('p')
      if (!!patternsParam) {
        const patterns = patternsParam.split(';')

        bpm = parseInt(patterns.shift())

        patterns.forEach((pattern, index) => {
          data[index] = []

          if (!!pattern) {
            const rows = pattern.split('-')
            const tone = parseInt(rows.shift())
            const rootNote = rows.shift().replace('S', '#')
            const octave = parseInt(rows.shift())

            tones[index] = tone
            rootNotes[index] = rootNote
            octaves[index] = octave
            generateNotes(index)

            if (rows.length) {
              rows.forEach((row) => {
                const columnIndex = parseInt(row[0], 16)
                const noteIndex = parseInt(row[1], 16)
                data[index][columnIndex] = noteIndex
              })
            }
          }
        })
      } else {
        tones[0] = 1
        rootNotes[0] = 'C'
        octaves[0] = 3
        generateNotes(index)
      }

      createCharts()
      paintAll()
      setInsts()
      setRoots()
      setOctaves()
      generateTones()

      // hook up bpm
      const bpmInput = document.querySelector('#bpm')
      bpmInput.value = bpm
      bpmInput.onchange = (e) => {
        changeTempo(e)
      }

      // set info line to current pattern data
      const line = document.querySelector('.line')
      line.innerText = data

      const tables = document.querySelectorAll('table')

      forEach(tables, (tableIndex, table) => {
        const trs = table.querySelectorAll(':scope tr')

        forEach(trs, (rowIndex, tr) => {
          const tds = tr.querySelectorAll(':scope td')

          forEach(tds, (dataIndex, td) => {
            td.onclick = (e) => {
              if (data[tableIndex][dataIndex] === rowIndex) {
                data[tableIndex][dataIndex] = null
              } else {
                data[tableIndex][dataIndex] = rowIndex
              }

              history.replaceState(null, '', '?p=' + encodeAll())
              paintAll()
              generateTones()
            }
          })
        })
      })
    }

    const encodeAll = () => {
      let beatString = '';

      beatString = beatString.concat(bpm, ';')

      // initialArray.reduce(function(result, value, index, array) {
      //   if (index % 2 === 0)
      //     result.push(array.slice(index, index + 2));
      //   return result;
      // }, []);

      data.forEach((chart, index) => {
        beatString = beatString.concat(tones[index], '-')
        beatString = beatString.concat(rootNotes[index].replace('#', 'S'), '-')
        beatString = beatString.concat(octaves[index], '-')

        chart.forEach((noteIndex, index) => {
          if (noteIndex !== null && noteIndex !== undefined) {
            beatString = beatString.concat(index.toString(16).toUpperCase(), noteIndex.toString(16).toUpperCase(), '-')
          }
        })

        beatString = beatString.slice(0, -1)
        beatString = beatString.concat(';')
      })

      return beatString.slice(0, -1)
    }

    const generateNoteFrequency = (multiplier, root) => {
      let val = root

      for (let i = 0; i < multiplier; i++) {
        val = val * toneConstant
      }

      return parseInt(val)
    }

    const generateTones = () => {
      let buffering = buffer.getChannelData(0)
      let carryover = 0
      let waveIndex = 0
      let freq = 0
      let samplesPerWave = 0

      for (let i = 0; i < buffering.length; i++) {
        buffering[i] = 0
      }

      data.forEach((beatData, chartIndex) => {
        beatData.forEach((noteIndex, beatIndex) => {
          if (noteIndex !== null && noteIndex !== undefined) {
            let bufferPointer = beatIndex * subBufferSize // start of the "16th" subsection
            let localIndex = 0

            while (carryover > 0) {
              buffering[bufferPointer + localIndex] = triangleSample(waveIndex, samplesPerWave)
              localIndex++
              waveIndex++
              carryover--
            }

            waveIndex = 0
            freq = notes[chartIndex][noteIndex]
            samplesPerWave = parseInt(sampleRate / freq)

            while (localIndex < subBufferSize) {
              let sample
              
              if (tones[chartIndex] === 0) {
                sample = squareSample(waveIndex, samplesPerWave)
              } else if (tones[chartIndex] === 1) {
                sample = sineSample(waveIndex, samplesPerWave)
              } else if (tones[chartIndex] === 2) {
                sample = triangleSample(waveIndex, samplesPerWave)
              } else if (tones[chartIndex] === 3) {
                sample = fuzzSample(waveIndex, samplesPerWave)
              } else {
                sample = squareSample(waveIndex, samplesPerWave)
              }

              let value = buffering[bufferPointer + localIndex] || 0.0

              value += sample

              if (value > 1.0)
                value = 1.0
              else if (value < -1.0)
                value = -1.0

              buffering[bufferPointer + localIndex] = value

              waveIndex++
              localIndex++

              if (waveIndex >= samplesPerWave) waveIndex = 0
            }

            carryover = samplesPerWave - waveIndex
          }
        })
      })
    }

    const squareSample = (index, samplesPerWave) => {
      return index <= parseInt(samplesPerWave / 2) ? 0.8 : -0.8
    }

    const fuzzSample = (index, samplesPerWave) => {
      return index <= parseInt(samplesPerWave / 2) ? Math.random() : Math.random() - 1
    }

    const triangleSample = (index, samplesPerWave) => {
      const halfSamples = parseInt(samplesPerWave / 2)
      const quarterSamples = parseInt(samplesPerWave / 4)
      const ramp = 1 / quarterSamples
      
      if (index <= halfSamples) {
        if (index <= quarterSamples) {
          return index * ramp
        } else {
          return (halfSamples - index) * ramp
        }
      } else {
        if (index <= halfSamples + quarterSamples) {
          return -((index - halfSamples) * ramp)
        } else {
          return -((samplesPerWave - index) * ramp)
        }
      }
    }

    const sineSample = (index, samplesPerWave) => {
      return Math.sin(index / (samplesPerWave / (Math.PI * 2)))
    }

    const play = () => {
      stop()
      bufferSource = audioCtx.createBufferSource()
      bufferSource.connect(audioCtx.destination)
      bufferSource.buffer = buffer
      bufferSource.onended = () => { playing = false }
      bufferSource.start()
      playing = true
    }

    const loop = () => {
      stop()
      bufferSource = audioCtx.createBufferSource()
      bufferSource.connect(audioCtx.destination)
      bufferSource.buffer = buffer
      bufferSource.onended = () => { playing = false }
      bufferSource.loop = true
      bufferSource.start()
      playing = true
    }

    const stop = () => {
      if (!!bufferSource) {
        try { bufferSource.stop() }
        catch (e) {}
      }
    }

    init()
  </script>
</html>
